# Pacman Doc
I decided to favor composition over inheritance and implemented a system much like the Unity engine is utilizing. Every object in the game is represented by the `GameEntity` class which contains methods to awake, start and update the entity in the world and its position. Any additional functionality is then added through components which are updated each frame in the `GameEntity`'s `Update()` method. Each component is precided by `C_`. This decision was made for better maintainability and robustness of the code. All entities in the game can be treated the same way without the need of casting. It also allows for separation of systems such as drawing and collision from the objects themselves.

The class that handles all the entities in the game is called `EntityManager`. Each entity in the game has to be added to the world through the `Add()` method and is updated each frame through the `Update()` method. When added the entities are stored in a temporary vector and then moved to a vector of all entities on the `ProcessNewEntites()` call. The method first calls `Awake()` and then `Start()` method on each of the entities. This ensures that all the `Awake()` methods will be called before all the `Start()` methods and we can implement the corresponding methods in the components with this being accounted for. To remove entities from the world we call the `SetDelete()` method on them which set the delete flag and the entities are actually removed from the vector of all entities in the `ProcessRemovals()` method.

There are 2 special components, namely `C_Sprite` and `C_Collision`, which require their own systems for management, `S_Sprite` and `S_Collision` respectively, and are stored and operated on from `EntityManager`.

One of the problems of the original version which drew the FPS down considerably was that images for each entity where loaded on every frame. To avoid this problem, all the images are loaded and stored in the memory through the `Drawer` class once, when the `C_Sprite` component is added to an entity and then they are simply retrieved from a hashmap on each subsequent call of the `Draw()`. The `Drawer` class also communicates with the SDL interface to draw the images on the screen. The `S_Sprite` then serves as an extension of the `EntityManager` class with all the corresponding methods for addition, update and removal of the entities' sprites but separated from `EntityManager` for better maintainability.

The `S_Collision` class is very much the same in this manner and the `C_Collision` component is a simplified version of a collision component with just 2 channels represented by the `CollisionLayer` enum, namely `Player` and `NonPlayer`. All the entities of the `Player` layer are checked against all the entities of the `NonPlayer` layer and if a collision is detected, the `Resolve()` method is called to resolve the overlap. The resolution is handled much like in Unreal engine, where we bind functions to the overlap events, here implemented in the `BindOverlapFunc()` method in the `C_Collision` class where we pass `std::function` to the component that will be called in `Resolve()`. The whole component and the component management is designed such that any entity can have collision and any binded functionality is not tightly coupled to the type of entity that it operates on.

The movement logic in the original version was implemented in the `Ghost` and `Avatar` classes which both inherited from the `MovableGameEntity` class. I decided to scratch this due to too many inheritance layers that made the code hard to read and to extend. The avatar movement logic was moved to the `InputManager` class and the `C_KeyboardMovement` component and the ghost movement logic to the `C_GhostBehaviour` component. This also includes any functionality that was previously implemented in the `Pacman` class.

The `InputManager` class simply stores a hashmap that maps the keys defined by the `Key` enum to the SDL scan codes and determines whether a key is pressed. This is then used in the `C_KeyboardMovement` class to determine which way to move. The component also store reference to the `C_Animation` component which changes the avatar animation based on the direction of the movement. Another change to the original version is that the avatar now doesn't stop when moved in a direction without a passage but rather continues without a stop and only changes the direction when a passage is open and a corresponding key is pressed. This greatly enhances the ease of the keyboard input and the fluidity of the avatar movement.

The `C_GhostBehavior` component implements all of the ghost movement logic including the pathfinding and the reversal of movement on the big dot eaten. Unlike the original version the pathfinding is implemented iteratively rather than recursively for the performance and it is utilized for both going towards and running away from the avatar and for going to the spawning location. The pathfinding utilized A* algorithm as it is optimal and optimally efficient. The algorithm is implemented in the `Pathfinding()` method through `std::priority_queue` where the key for sorting best moves in the queue is `(the path travelled so far) + (manhattan distance towards target)`. The implementation through the priority queue also lends nicely to the reversal of the movement by just simply reversing the compare sign in the compare function for the priority queue.